from typing import TYPE_CHECKING

from hookscan.components.constant import ConstantInt
from hookscan.components.evm_instructions import Eq, Gt, Iszero, Lt, Sgt, Slt
from hookscan.components.instruction import BranchInst, SwitchInst
from hookscan.components.storage_instructions import StorageMappingIndexInst, StorageReadInst
from hookscan.core.instruction_instance import ValueInstance
from hookscan.utils.clear_condition import clear_condition

if TYPE_CHECKING:
    from hookscan.core.traversal_info import TraversalInfo


class ProtectHandler:
    def __init__(
        self,
    ) -> None:
        pass

    def init_info(self, info: "TraversalInfo"):
        self.info = info

    def add_protect_index_list(self, real_condition_choose: bool):
        if not (
            real_condition_choose is not None and self.info.fork_index_list[-1] == len(self.info.path) - 2
        ):  # Check if the previous node of this path node is generated by a branch
            # the logic for push and pop will be handled after the "if" statement.
            return

        assert isinstance(
            self.info.path[self.info.fork_index_list[-1]].inst_instances[-1].value,
            (BranchInst, SwitchInst),
        )
        condition = self.info.path[self.info.fork_index_list[-1]].inst_instances[-1].operand_instances[0].origin
        if self.condition_end_with_exclude_inst(condition):
            if self.ignore_exactly_special_case(condition):
                return
            self._add_protect_index_list(condition)
            return

        if self.should_consider_protect(condition, real_condition_choose):
            self._add_protect_index_list(condition)

    def condition_end_with_exclude_inst(self, condition: ValueInstance):
        _, inner_condition = clear_condition(condition)
        if isinstance(inner_condition.origin.value, (Lt, Gt, Slt, Sgt)):
            return True
        else:
            return False

    # NOTE: Some special cases can be ignored for protect
    def ignore_exactly_special_case(self, condition: ValueInstance):
        _, inner_condition = clear_condition(condition)
        if isinstance(inner_condition.origin.value, (Gt, Lt, Slt, Sgt)):
            flag_one = False
            for index in (0, 1):
                if (
                    isinstance(
                        inner_condition.origin.operand_instances[1 - index].origin.value,
                        ConstantInt,
                    )
                    and inner_condition.origin.operand_instances[1 - index].origin.value.value == 0  # pyright: ignore
                    and not (
                        "caller" in inner_condition.origin.operand_instances[index].origin.taints
                        and "_storageread" in inner_condition.origin.operand_instances[index].origin.taints
                    )
                ):
                    if flag_one:
                        return True
                    else:
                        flag_one = True
        return False

    def should_consider_protect(self, condition: ValueInstance, real_condition_choose: bool):
        # NOTE: Given the condition and which path is taken, return whether to consider adding protect.
        # NOTE: This return result does not necessarily mean that it should be set as protect, as other factors such as taints need to be considered.

        mapping_check_with_zero = self.mapping_check_with_zero(condition)
        has_neg = self.is_neg_condition(condition)  # Whether there is a negation operation in the source code
        has_neg = not has_neg if mapping_check_with_zero else has_neg

        is_require = (
            self.info.get_call_stack_names()[-1].startswith("require_helper")
            if len(self.info.get_call_stack_names()) > 0
            else False
        )
        if not is_require:
            if has_neg and real_condition_choose:
                pass
            elif has_neg and not real_condition_choose:
                return True
            elif not has_neg and not real_condition_choose:
                pass
            elif not has_neg and real_condition_choose:
                return True
        else:
            if not has_neg:
                if not real_condition_choose:
                    return True
            else:
                pass
        return False

    def is_neg_condition(self, condition: ValueInstance):
        # Returns whether the source code has a negation operation
        # It depends on whether the condition is wrapped in iszero. Note that require and if statements are different.
        # require has an iszero operation built in.
        is_zero_number, _ = clear_condition(condition)
        is_require = (
            self.info.get_call_stack_names()[-1].startswith("require_helper")
            if len(self.info.get_call_stack_names()) > 0
            else False
        )
        if is_require:
            is_zero_number -= 1
        #
        return is_zero_number % 2 == 1

    def is_last_reference_type_mapping(self, vi):
        return isinstance(vi.operand_instances[0].origin.value, StorageMappingIndexInst)

    def mapping_check_with_zero(self, condition: ValueInstance):
        _, inner_condition = clear_condition(condition)

        if isinstance(inner_condition.value, Eq):
            for value_index in (0, 1):
                mapping_index = 1 - value_index
                if (
                    isinstance(inner_condition.operand_instances[value_index].origin.value, ConstantInt)
                    and inner_condition.operand_instances[value_index].origin.value.value == 0  # pyright: ignore
                    and isinstance(
                        inner_condition.operand_instances[mapping_index].origin.value,
                        StorageReadInst,
                    )
                    and self.is_last_reference_type_mapping(inner_condition.operand_instances[mapping_index].origin)
                ):
                    return True
        return False

    def _add_protect_index_list(self, condition: ValueInstance):
        _, inner_condition = clear_condition(condition)
        if isinstance(inner_condition.origin.value, (Lt, Gt, Slt, Sgt, Eq)):
            self._add_protect_index_list_in_binary_operator(inner_condition.origin)
        else:
            self._add_protect_index_list_in_unary_operator(inner_condition.origin)

    def _add_protect_index_list_in_binary_operator(self, condition: ValueInstance):
        assert isinstance(condition.origin.value, (Lt, Gt, Slt, Sgt, Eq))
        if self.is_Merkle_tree(condition):
            self.info.protect_index_list.append(len(self.info.path) - 1)
            return
        for operand_index in (0, 1):
            if (
                (
                    "caller" in condition.operand_instances[operand_index].taints
                    or "origin" in condition.operand_instances[operand_index].taints
                    or "_ecrecover" in condition.operand_instances[operand_index].taints
                )
                and "_array_length" not in condition.operand_instances[operand_index].taints
                and any(
                    x in condition.operand_instances[1 - operand_index].taints
                    for x in (
                        "_storageread",
                        "_loadimmutable",
                        "_constant",
                        "_address",
                        "_high_level_call_ownerof",
                        "_high_level_call_isApprovedForAll",
                        "_high_level_call_getApproved",
                    )
                )
                and (
                    "calldata" not in condition.operand_instances[1 - operand_index].taints
                    or any(
                        x in condition.operand_instances[1 - operand_index].taints
                        for x in (
                            "_high_level_call_ownerof",
                            "_high_level_call_isApprovedForAll",
                            "_high_level_call_getApproved",
                            "_storageread",
                        )
                    )
                )  # The value being compared to `caller` should not be controlled by `calldata`, but it can be controlled in the case of high-level calls.
            ):
                if not (
                    "returndata" in condition.taints
                    and "_is_not_consider_protect_standard_returndata" in condition.taints
                ):
                    self.info.protect_index_list.append(len(self.info.path) - 1)
                    return

    def _add_protect_index_list_in_unary_operator(self, condition: ValueInstance):
        assert not isinstance(condition.origin.value, (Lt, Gt, Slt, Sgt, Eq)) and not isinstance(
            condition.origin.value, Iszero
        )
        if "caller" in condition.taints or "origin" in condition.taints or "_ecrecover" in condition.taints:
            if not (
                "returndata" in condition.taints and "_is_not_consider_protect_standard_returndata" in condition.taints
            ):
                if "_array_length" not in condition.taints:
                    if any(
                        x in condition.taints
                        for x in (
                            "_storageread",
                            "_loadimmutable",
                            "_constant",
                            "_address",
                            "_high_level_call_ownerof",
                            "_high_level_call_isApprovedForAll",
                            "_high_level_call_getApproved",
                        )
                    ):
                        self.info.protect_index_list.append(len(self.info.path) - 1)

    def is_Merkle_tree(self, condition: ValueInstance):
        if not isinstance(condition.origin.value, Eq):
            return False
        for operand_index in (0, 1):
            if (
                any(
                    x in condition.operand_instances[operand_index].taints
                    for x in ("_storageread", "_loadimmutable", "_constant")
                )
                and "_keccak256_after_calldata" in condition.operand_instances[1 - operand_index].taints
            ):
                return True
        return False

    def pop_protect(self):
        if self.info.protect_index_list and self.info.protect_index_list[-1] >= len(self.info.path) - 1:
            self.info.protect_index_list.pop()
